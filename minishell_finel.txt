NAME = minishell
SRC_DIR = src
OBJ_DIR = .objs

# Usar todos os arquivos .c no diret√≥rio sources
SRC = $(wildcard $(SRC_DIR)/*.c)

OBJ = $(patsubst $(SRC_DIR)/%.c, $(OBJ_DIR)/%.o, $(SRC))

CC = clang
HEAD = -I./includes
CFLAGS = -Wall -Werror -Wextra -g  -fsanitize=address
LFLAGS = -lreadline
RM = /bin/rm -rf

all: $(NAME)

$(NAME): $(OBJ)
                @$(CC) $(OBJ) $(HEAD) $(CFLAGS) $(LFLAGS) -o $(NAME)

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
                @mkdir -p $(OBJ_DIR)
                @$(CC) $(CFLAGS) $(HEAD) -c $< -o $@

clean:
                @$(RM) $(OBJ_DIR)

fclean: clean
                @$(RM) $(NAME)

re: fclean all

.PHONY: all clean fclean re


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:46:46 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:46:47 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <fcntl.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>
# include <sys/wait.h>
# include <unistd.h>

# define D_QUOTE '\"'
# define QUOTE '\''
# define D_QUOTE_S "\""
# define QUOTE_S "\'"

# define ERROR_PIPE "minishell: syntax error near unexpected token `|'\n"
# define ERROR_DIR "No such file or directory\n"
# define ERROR_HOME "minishell: cd: HOME not set\n"
# define ERROR_CMD "command not found\n"

typedef struct s_struct t_tiny;
typedef struct s_env    t_env;
typedef struct s_split  t_split;
typedef struct s_token  t_token;

struct                                  s_env
{
        char                            **env;
        int                                     len;
        char                            **key;
        char                            **content;
        int                                     index;
};

struct                                  s_split
{
        int                                     n_comand;
        int                                     ini;
        int                                     len;
        int                                     q;
        int                                     qtt_pipe;
};

struct                                  s_token
{
        char                            *to_print;
        char                            *to_exec;
        char                            quote;
        char                            *end;
        char                            *new;
        int                                     i;
        int                                     init;
        int                                     len;
        int                                     posic;
};

struct                                  s_struct
{
        int                                     last_exit_cmd;
        bool                            is_builtin;
        bool                            has_flag;
        int                                     is_append;
        int                                     last_redir;
        int                                     out_fd;
        int                                     in_fd;
        int                                     num_tokens;
        int                                     c;
        char                            quote;
        char                            *line;
        char                            *line_read;
        char                            *name_file;
        char                            *error_name_file;
        char                            *home;
        char                            *commands[50];
        char                            *token_aux;
        char                            **tokens;
        char                            **path;
        t_env                           env_aux;
        t_env                           env;
        t_split                         split;
        t_token                         token;
};

void                                    init_1(t_tiny *tiny);
void                                    init_environment(t_tiny *tiny);
void                                    init_tiny_env(t_tiny *tiny);
int                                             fix(t_tiny *tiny, char c, char *aux, int nbr);
void                                    is_builtin(char *cmd, t_tiny *tiny);
void                                    run_builtin(t_tiny *tiny);
char                                    *find_env(t_tiny *tiny, char *needle);
int                                             ft_cd(t_tiny *tiny);
bool                                    there_is_home(t_tiny *tiny);
void                                    ft_echo(t_tiny *tiny);
int                                             init_echo(t_tiny *tiny, int n);
void                                    print_echo(t_tiny *tiny, char *tiny_tokens_i);
void                                    ft_env(t_tiny *tiny);
void                                    create_env(t_tiny *tiny, char **my_env);
void                                    len_env(t_tiny *tiny);
void                                    init_tiny_env(t_tiny *tiny);
void                                    ft_exit(t_tiny *tiny);
void                                    free_line(char *line_read);
void                                    free_char_array(char **array);
void                                    free_char_array2(char **array);
void                                    ft_export(t_tiny *tiny);
void                                    verify_if_env_exists(t_tiny *tiny, char **env_aux,
                                                        int i);
void                                    add_env(t_tiny *tiny, char *new_key, char *new_content);
void                                    ft_pwd(t_tiny *tiny);
char                                    *get_cwd_buf(void);
void                                    ft_unset(t_tiny *tiny);
void                                    rm_env(t_tiny *tiny);
void                                    alloc_env_aux(t_tiny *tiny);
int                                             init_path(t_tiny *tiny);
int                                             main(void);
void                                    init(t_tiny *tiny);
void                                    redirect_in(t_tiny *tiny, int j, char *aux);
char                                    **double_redir(t_tiny *tiny, char **file, int j);
void                                    read_until(char *end);
char                                    *new_comman(int i, char **str);
void                                    redirect_out(t_tiny *tiny, int j);
void                                    simple_redir_out(t_tiny *tiny, int j, int flags);
int                                             find_char(char *string, char needle);
int                                             file_descriptor_handler(int in, int out);
void                                    spaces_in_pipe(t_tiny *tiny, int i, char *command);
void                                    execve_error(t_tiny *tiny);
void                                    run_commands(t_tiny *tiny);
void                                    run_commands_aux(t_tiny *tiny);
void                                    action(t_tiny *tiny);
void                                    exec_process(t_tiny *tiny, int in, int out);
void                                    ft_execve_pipe(t_tiny *tiny, int i, char *command);
void                                    run_signals(int sig);
void                                    restore_prompt(int sig);
void                                    ctrl_c(int sig);
void                                    back_slash(int sig);
void                                    split_cmd(t_tiny *tiny, char *in, int i);
void                                    init_split_tiny(t_tiny *tiny);
char                                    *clean_spaces(char *in);
int                                             count_pipe(t_tiny *tiny, char *in, int i);
void                                    tokenizer(t_tiny *tiny);
void                                    simple_quotes(t_tiny *tiny, char *in, int i, int c);
int                                             tokent(char *string, char needle);
void                                    get_home_sign(t_tiny *tiny, t_token *tk);
void                                    get_dollar_sign(t_tiny *tiny, t_token *tk);
t_token                                 *init_tk(void);
void                                    free_tk(t_token *tk);
void                                    finish_tokenizer(t_tiny *tiny, t_token *tk);
int                                             count_digits(int n);
int                                             power(int n_digits);
char                                    *ft_itoa(int n);
char                                    *substr_ft(char const *s, unsigned int start,
                                                        size_t len);
int                                             ft_isset(char c, char const *set);
char                                    *ft_strtrim(char const *s1, char const *set);
char                                    *ft_strjoin(char const *s1, char const *s2);
void                                    ft_putendl_fd(char *s, int fd);
int                                             count_words(const char *s, char c);
char                                    *string(const char *s, int init, int end);
char                                    **ft_split(char const *s, char c);
void                                    ft_putstr_fd(char *s, int fd);
int                                             ft_strncmp(const char *s1, const char *s2, size_t n);
size_t                                  ft_strlen(const char *str);
size_t                                  ft_strlcpy(char *restrict dst, const char *restrict src,
                                                        size_t dstsize);
char                                    *ft_strdup(const char *s1);
void                                    ft_putnbr_fd(int n, int fd);
void                                    ft_putchar_fd(char c, int fd);
void                                    print_header(void);
void                                    ft_print(char *message);

#endif

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:33:06 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:33:07 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    is_builtin(char *cmd, t_tiny *tiny)
{
        if ((!ft_strncmp("echo", cmd, 4) && ft_strlen(cmd) == 4)
                || (!ft_strncmp("cd", cmd, 2) && ft_strlen(cmd) == 2)
                || (!ft_strncmp("pwd", cmd, 3) && ft_strlen(cmd) == 3)
                || (!ft_strncmp("export", cmd, 6) && ft_strlen(cmd) == 6)
                || (!ft_strncmp("unset", cmd, 5) && ft_strlen(cmd) == 5)
                || (!ft_strncmp("env", cmd, 3) && ft_strlen(cmd) == 3)
                || (!ft_strncmp("exit", cmd, 4) && ft_strlen(cmd) == 4))
                tiny->is_builtin = true;
        else
                tiny->is_builtin = false;
}

void    run_builtin(t_tiny *tiny)
{
        if (!ft_strncmp(tiny->tokens[0], "exit", 4))
                ft_exit(tiny);
        if (!ft_strncmp(tiny->tokens[0], "pwd", 3))
                ft_pwd(tiny);
        if (!ft_strncmp(tiny->tokens[0], "echo", 4))
                ft_echo(tiny);
        if (!ft_strncmp(tiny->tokens[0], "cd", 2))
                ft_cd(tiny);
        if (!ft_strncmp(tiny->tokens[0], "env", 3))
                ft_env(tiny);
        if (!ft_strncmp(tiny->tokens[0], "export", 6))
                ft_export(tiny);
        if (!ft_strncmp(tiny->tokens[0], "unset", 5))
                ft_unset(tiny);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_env.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:35:01 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:35:02 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_env(t_tiny *tiny)
{
        int     i;

        i = 0;
        while (i < tiny->env.len)
        {
                ft_putstr_fd(tiny->env.key[i], tiny->out_fd);
                ft_putchar_fd('=', tiny->out_fd);
                ft_putendl_fd(tiny->env.content[i], tiny->out_fd);
                i++;
        }
        tiny->last_exit_cmd = 0;
}

void    create_env(t_tiny *tiny, char **my_env)
{
        int             i;
        char    **env_aux;

        tiny->env.env = my_env;
        len_env(tiny);
        init_tiny_env(tiny);
        i = 0;
        while (tiny->env.env[i])
        {
                env_aux = ft_split(tiny->env.env[i], '=');
                tiny->env.key[i] = ft_strdup(env_aux[0]);
                if (env_aux[1])
                        tiny->env.content[i] = ft_strdup(env_aux[1]);
                else
                        tiny->env.content[i] = ft_strdup("");
                free_char_array(env_aux);
                i++;
        }
        tiny->env.key[i] = NULL;
        tiny->env.content[i] = NULL;
}

void    len_env(t_tiny *tiny)
{
        int     i;

        i = 0;
        while (tiny->env.env[i])
                i++;
        tiny->env.len = i;
}

void    init_tiny_env(t_tiny *tiny)
{
        tiny->env.key = malloc(sizeof(char *) * (tiny->env.len + 1));
        if (!tiny->env.key)
                exit(EXIT_FAILURE);
        tiny->env.content = malloc(sizeof(char *) * (tiny->env.len + 1));
        if (!tiny->env.content)
                exit(EXIT_FAILURE);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:37:16 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:37:18 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     main(void)
{
        t_tiny  tiny;

        init(&tiny);
        while (1)
        {
                init_1(&tiny);
                tiny.line_read = readline("<minishell>");
                if (tiny.line_read)
                {
                        add_history(tiny.line_read);
                        if (ft_strlen(tiny.line_read) != 0)
                        {
                                split_cmd(&tiny, tiny.line_read, 0);
                                if (tiny.split.n_comand > 0 && tiny.commands[0][0] != '|')
                                        run_commands(&tiny);
                                if (tiny.commands[0] && tiny.commands[0][0] == '|')
                                        printf(ERROR_PIPE);
                                free_char_array2(tiny.commands);
                        }
                        free(tiny.line_read);
                }
                else
                        run_signals(3);
        }
}

void    init_1(t_tiny *tiny)
{
        tiny->out_fd = STDOUT_FILENO;
        tiny->in_fd = STDIN_FILENO;
        run_signals(1);
}

void    init(t_tiny *tiny)
{
        int     i;

        i = 0;
        tiny->last_exit_cmd = 0;
        tiny->is_builtin = false;
        tiny->has_flag = false;
        tiny->is_append = 0;
        tiny->last_redir = 0;
        tiny->out_fd = STDOUT_FILENO;
        tiny->in_fd = STDIN_FILENO;
        tiny->num_tokens = 0;
        tiny->c = 0;
        tiny->quote = '\0';
        tiny->line = NULL;
        tiny->line_read = NULL;
        tiny->name_file = NULL;
        tiny->error_name_file = NULL;
        tiny->home = NULL;
        tiny->token_aux = NULL;
        while (i < 50)
        {
                tiny->commands[i] = NULL;
                i++;
        }
        init_environment(tiny);
}

void    init_environment(t_tiny *tiny)
{
        tiny->tokens = NULL;
        tiny->path = NULL;
        print_header();
        create_env(tiny, __environ);
        init_path(tiny);
        tiny->home = ft_strdup(find_env(tiny, "HOME"));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_out.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:37:39 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:37:41 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    redirect_out(t_tiny *tiny, int j)
{
        int             flags;
        char    *file;

        flags = O_WRONLY | O_CREAT;
        j = tiny->c;
        if (tiny->commands[j] && tiny->commands[j][0] == '>')
        {
                if (tiny->commands[j] && tiny->commands[j][1] == '>')
                {
                        file = ft_strtrim(&tiny->commands[j][2], " ");
                        tiny->out_fd = open(file, flags | O_APPEND, 0777);
                        free(file);
                }
                else
                        simple_redir_out(tiny, j, flags);
                tiny->last_redir = 1;
                if (tiny->split.n_comand == 1)
                        free(tiny->line);
        }
}

void    simple_redir_out(t_tiny *tiny, int j, int flags)
{
        char    *aux;
        char    *file;

        aux = ft_strtrim(&tiny->commands[j][1], " ");
        file = substr_ft(aux, 0, find_char(aux, ' '));
        tiny->out_fd = open(file, flags | O_TRUNC, 0777);
        free(aux);
        free(file);
}

int     find_char(char *string, char needle)
{
        int     i;

        i = 0;
        while (string[i])
        {
                if (string[i] == needle)
                        return (i);
                i++;
        }
        return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   split_cmd.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:38:23 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:38:25 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    split_cmd(t_tiny *tiny, char *in, int i)
{
        init_split_tiny(tiny);
        in = clean_spaces(in);
        while (i < (int)ft_strlen(in))
        {
                if (tiny->split.q == 0 && (in[i] == D_QUOTE || in[i] == QUOTE))
                        tiny->split.q = in[i];
                else
                {
                        if (tiny->split.q == in[i])
                                tiny->split.q = 0;
                        else
                                i = count_pipe(tiny, in, i);
                }
                tiny->split.len++;
                i++;
        }
        if (ft_strlen(in) > 0)
        {
                tiny->commands[tiny->split.n_comand] = substr_ft(in, tiny->split.ini,
                                i);
                tiny->split.n_comand++;
        }
        free(in);
        tiny->commands[tiny->split.n_comand] = NULL;
}

void    init_split_tiny(t_tiny *tiny)
{
        tiny->split.n_comand = 0;
        tiny->split.ini = 0;
        tiny->split.len = 0;
        tiny->split.qtt_pipe = 0;
        tiny->split.q = 0;
        tiny->last_redir = 0;
}

char    *clean_spaces(char *in)
{
        char    *aux;

        aux = ft_strtrim(in, " ");
        in = aux;
        return (in);
}

int     count_pipe(t_tiny *tiny, char *in, int i)
{
        if (in[i] == '|' || in[i] == '<' || in[i] == '>')
        {
                if (in[i] == '|' && tiny->split.q == 0)
                        tiny->split.qtt_pipe++;
                if (tiny->split.q == 0 && i > 1 && tiny->split.len > 0)
                {
                        tiny->commands[tiny->split.n_comand] = substr_ft(in,
                                        tiny->split.ini, tiny->split.len);
                        tiny->split.ini = i;
                        tiny->split.len = 0;
                        tiny->split.n_comand++;
                        if (in[i] == '>')
                                tiny->last_redir = 1;
                        else
                                tiny->last_redir = 0;
                        if (in[i] == in[i + 1])
                        {
                                i++;
                                tiny->split.len = 1;
                        }
                }
        }
        return (i);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:33:19 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:33:20 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char    *find_env(t_tiny *tiny, char *needle)
{
        int     i;
        int     len;
        int     len_needle;

        i = 0;
        tiny->env.index = 0;
        len_needle = ft_strlen(needle);
        while (tiny->env.key[i] && i < tiny->env.len)
        {
                len = ft_strlen(tiny->env.key[i]);
                if (!ft_strncmp(tiny->env.key[i], needle, len_needle)
                        && len == len_needle)
                {
                        tiny->env.index = i;
                        return (tiny->env.content[i]);
                }
                i++;
        }
        return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:35:18 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:35:19 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_exit(t_tiny *tiny)
{
        free_char_array2(tiny->commands);
        if (tiny->path)
                free_char_array(tiny->path);
        free(tiny->home);
        printf("exit\n");
        exit(0);
}

void    free_line(char *line_read)
{
        if (line_read)
        {
                free(line_read);
                line_read = (char *) NULL;
        }
}

void    free_char_array(char **array)
{
        int     i;

        i = 0;
        while (array[i] != NULL)
        {
                free(array[i]);
                array[i] = NULL;
                i++;
        }
        free(array);
}

void    free_char_array2(char **array)
{
        int     i;

        i = 0;
        while (array[i] != NULL)
        {
                free(array[i]);
                array[i] = NULL;
                i++;
        }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   functions_3.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:33:38 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:33:39 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     count_words(const char *s, char c)
{
        int     i;
        int     n_word;
        int     control;

        i = 0;
        control = 0;
        n_word = 0;
        while (s[0] != '\0' && s[i] != '\0')
        {
                if (s[i] != c && control == 0)
                {
                        control = 1;
                        n_word++;
                }
                else if (s[i] == c)
                        control = 0;
                i++;
        }
        return (n_word);
}

char    *string(const char *s, int init, int end)
{
        char    *string;
        int             i;

        i = 0;
        string = (char *)malloc((end - init + 1) * sizeof(char));
        while (end > init)
        {
                string[i] = s[init];
                i++;
                init++;
        }
        string[i] = '\0';
        return (string);
}

char    **ft_split(char const *s, char c)
{
        char    **split;
        int             init_w;
        size_t  i;
        size_t  j;

        if (s == 0)
                return (NULL);
        i = -1;
        j = 0;
        init_w = -1;
        split = malloc((count_words(s, c) + 1) * sizeof(char *));
        if (split == 0)
                return (NULL);
        while (++i <= ft_strlen(s))
        {
                if (s[i] != c && init_w < 0)
                        init_w = i;
                else if ((s[i] == c || i == ft_strlen(s)) && init_w >= 0)
                {
                        split[j++] = string(s, init_w, i);
                        init_w = -1;
                }
        }
        split[j] = NULL;
        return (split);
}

void    ft_putstr_fd(char *s, int fd)
{
        int     i;

        i = 0;
        if (s != 0 && fd != 0)
        {
                while (s[i] != '\0')
                {
                        write(fd, &s[i], 1);
                        i++;
                }
        }
}

int     ft_strncmp(const char *s1, const char *s2, size_t n)
{
        size_t                  i;
        unsigned char   *str1;
        unsigned char   *str2;

        str1 = (unsigned char *)s1;
        str2 = (unsigned char *)s2;
        i = 0;
        while ((str1[i] != '\0' || str2[i] != '\0') && i < n)
        {
                if (str1[i] != str2[i])
                        return (str1[i] - str2[i]);
                i++;
        }
        return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   printer.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:39:03 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:39:04 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_print(char *message)
{
        write(STDOUT_FILENO, message, ft_strlen(message));
}

void    print_header(void)
{
        ft_print("\033[1;32m");
        ft_print("*****************************************"
                "********************************\n");
        ft_print("*  __  __  _____  _   _  _____   _____"
                "  _    _  ______  _       _            *\n");
        ft_print("* |  \\/  ||_   _|| \\ | ||_   _| /"
                " ____|| |  | ||  ____|| |     | |      *\n");
        ft_print("* | \\  / |  | |  |  \\| |  | |  "
                "| (___  | |__| || |__   | |     | |    *\n");
        ft_print("* | |\\/| |  | |  | . ` |  | |   "
                "\\___ \\ |  __  ||  __|  | |     | |   *\n");
        ft_print("* | |  | | _| |_ | |\\  | _| |_  ____) "
                "|| |  | || |____ | |____ | |____       *\n");
        ft_print("* |_|  |_||_____||_| \\_||_____||_____/ "
                "|_|  |_||______||______||______|       *\n");
        ft_print("**********************************"
                "***************************************        \n");
        ft_print("\033[1;34m");
        ft_print("*                        by Sandro, Andr√©"
                "                             * *\n");
        ft_print("*************************************"
                "************************************\n");
        ft_print("\033[0m");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_pipe.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:37:49 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:37:51 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     file_descriptor_handler(int in, int out)
{
        if (in != 0)
        {
                dup2(in, 0);
                close(in);
        }
        if (out != 1)
        {
                dup2(out, 1);
                close(out);
        }
        return (0);
}

void    spaces_in_pipe(t_tiny *tiny, int i, char *command)
{
        char    *aux;

        if (ft_strlen(tiny->token.to_print) && tiny->tokens[i]
                && (tiny->tokens[i][0] == QUOTE || tiny->tokens[i][0] == D_QUOTE)
                && ft_strncmp(tiny->tokens[i - 1], "sed", 3))
        {
                aux = ft_strtrim(tiny->token.to_print, D_QUOTE_S);
                free_char_array2(&tiny->tokens[i + 1]);
        }
        else
                aux = ft_strtrim(tiny->tokens[i], D_QUOTE_S);
        free(tiny->tokens[i]);
        tiny->tokens[i] = aux;
        command = ft_strjoin(command, tiny->tokens[i - 1]);
        tiny->last_exit_cmd = execve(command, &tiny->tokens[i - 1], tiny->env.env);
        free(command);
}

void    execve_error(t_tiny *tiny)
{
        tiny->last_exit_cmd = 127;
        if (tiny->tokens[0][0] != '|')
                printf("minishell: %s: %s", tiny->tokens[0], ERROR_CMD);
        else if (tiny->tokens[1])
                printf("minishell: %s: %s", tiny->tokens[1], ERROR_CMD);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:38:32 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:38:33 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     tokent(char *string, char needle)
{
        int     i;

        i = 0;
        while (string[i])
        {
                if (string[i] == needle || string[i] == D_QUOTE || string[i] == QUOTE)
                        return (i);
                if (string[i] == '?')
                        return (i + 1);
                i++;
        }
        return (i);
}

int     fix(t_tiny *tiny, char c, char *aux, int nbr)
{
        if (tiny->token.quote == 0 && (c == QUOTE || c == D_QUOTE))
                tiny->token.quote = c;
        else
        {
                if (tiny->token.quote == c)
                        tiny->token.quote = 0;
                else
                {
                        aux[nbr] = c;
                        nbr++;
                }
        }
        return (nbr);
}

void    simple_quotes(t_tiny *tiny, char *in, int i, int c)
{
        char    *aux;

        tiny->token.quote = 0;
        aux = ft_strtrim(in, " ");
        tiny->has_flag = false;
        if (in[0] == '-' && in[1] == 'n')
        {
                tiny->has_flag = true;
                i += 2;
        }
        while (in[i] == ' ')
                i++;
        while (in[i])
        {
                c = fix(tiny, in[i], aux, c);
                i++;
        }
        aux[c] = '\0';
        free(tiny->token.to_print);
        tiny->token.to_print = aux;
}

void    tokenizer(t_tiny *tiny)
{
        t_token *tk;

        tk = init_tk();
        tiny->token.quote = 0;
        tk->end = ft_strdup("");
        if (tiny->line)
        {
                while ((int)ft_strlen(tiny->line) > tk->i)
                {
                        if (tiny->token.quote == 0 && (tiny->line[tk->i] == QUOTE))
                                tiny->token.quote = tiny->line[tk->i];
                        else
                        {
                                if (tiny->token.quote == tiny->line[tk->i])
                                        tiny->token.quote = 0;
                                if (tiny->line[tk->i] == '~' && tiny->token.quote == 0)
                                        get_home_sign(tiny, tk);
                                else if (tiny->line[tk->i] == '$' && tiny->token.quote == 0)
                                        get_dollar_sign(tiny, tk);
                        }
                        tk->len++;
                        tk->i++;
                }
                finish_tokenizer(tiny, tk);
        }
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:33:19 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:33:20 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char    *find_env(t_tiny *tiny, char *needle)
{
        int     i;
        int     len;
        int     len_needle;

        i = 0;
        tiny->env.index = 0;
        len_needle = ft_strlen(needle);
        while (tiny->env.key[i] && i < tiny->env.len)
        {
                len = ft_strlen(tiny->env.key[i]);
                if (!ft_strncmp(tiny->env.key[i], needle, len_needle)
                        && len == len_needle)
                {
                        tiny->env.index = i;
                        return (tiny->env.content[i]);
                }
                i++;
        }
        return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:35:18 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:35:19 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_exit(t_tiny *tiny)
{
        free_char_array2(tiny->commands);
        if (tiny->path)
                free_char_array(tiny->path);
        free(tiny->home);
        printf("exit\n");
        exit(0);
}

void    free_line(char *line_read)
{
        if (line_read)
        {
                free(line_read);
                line_read = (char *) NULL;
        }
}

void    free_char_array(char **array)
{
        int     i;

        i = 0;
        while (array[i] != NULL)
        {
                free(array[i]);
                array[i] = NULL;
                i++;
        }
        free(array);
}

void    free_char_array2(char **array)
{
        int     i;

        i = 0;
        while (array[i] != NULL)
        {
                free(array[i]);
                array[i] = NULL;
                i++;
        }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   functions_3.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:33:38 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:33:39 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     count_words(const char *s, char c)
{
        int     i;
        int     n_word;
        int     control;

        i = 0;
        control = 0;
        n_word = 0;
        while (s[0] != '\0' && s[i] != '\0')
        {
                if (s[i] != c && control == 0)
                {
                        control = 1;
                        n_word++;
                }
                else if (s[i] == c)
                        control = 0;
                i++;
        }
        return (n_word);
}

char    *string(const char *s, int init, int end)
{
        char    *string;
        int             i;

        i = 0;
        string = (char *)malloc((end - init + 1) * sizeof(char));
        while (end > init)
        {
                string[i] = s[init];
                i++;
                init++;
        }
        string[i] = '\0';
        return (string);
}

char    **ft_split(char const *s, char c)
{
        char    **split;
        int             init_w;
        size_t  i;
        size_t  j;

        if (s == 0)
                return (NULL);
        i = -1;
        j = 0;
        init_w = -1;
        split = malloc((count_words(s, c) + 1) * sizeof(char *));
        if (split == 0)
                return (NULL);
        while (++i <= ft_strlen(s))
        {
                if (s[i] != c && init_w < 0)
                        init_w = i;
                else if ((s[i] == c || i == ft_strlen(s)) && init_w >= 0)
                {
                        split[j++] = string(s, init_w, i);
                        init_w = -1;
                }
        }
        split[j] = NULL;
        return (split);
}

void    ft_putstr_fd(char *s, int fd)
{
        int     i;

        i = 0;
        if (s != 0 && fd != 0)
        {
                while (s[i] != '\0')
                {
                        write(fd, &s[i], 1);
                        i++;
                }
        }
}

int     ft_strncmp(const char *s1, const char *s2, size_t n)
{
        size_t                  i;
        unsigned char   *str1;
        unsigned char   *str2;

        str1 = (unsigned char *)s1;
        str2 = (unsigned char *)s2;
        i = 0;
        while ((str1[i] != '\0' || str2[i] != '\0') && i < n)
        {
                if (str1[i] != str2[i])
                        return (str1[i] - str2[i]);
                i++;
        }
        return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   printer.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:39:03 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:39:04 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_print(char *message)
{
        write(STDOUT_FILENO, message, ft_strlen(message));
}

void    print_header(void)
{
        ft_print("\033[1;32m");
        ft_print("*****************************************"
                "********************************\n");
        ft_print("*  __  __  _____  _   _  _____   _____"
                "  _    _  ______  _       _            *\n");
        ft_print("* |  \\/  ||_   _|| \\ | ||_   _| /"
                " ____|| |  | ||  ____|| |     | |      *\n");
        ft_print("* | \\  / |  | |  |  \\| |  | |  "
                "| (___  | |__| || |__   | |     | |    *\n");
        ft_print("* | |\\/| |  | |  | . ` |  | |   "
                "\\___ \\ |  __  ||  __|  | |     | |   *\n");
        ft_print("* | |  | | _| |_ | |\\  | _| |_  ____) "
                "|| |  | || |____ | |____ | |____       *\n");
        ft_print("* |_|  |_||_____||_| \\_||_____||_____/ "
                "|_|  |_||______||______||______|       *\n");
        ft_print("**********************************"
                "***************************************        \n");
        ft_print("\033[1;34m");
        ft_print("*                        by Sandro, Andr√©"
                "                             * *\n");
        ft_print("*************************************"
                "************************************\n");
        ft_print("\033[0m");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_pipe.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:37:49 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:37:51 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     file_descriptor_handler(int in, int out)
{
        if (in != 0)
        {
                dup2(in, 0);
                close(in);
        }
        if (out != 1)
        {
                dup2(out, 1);
                close(out);
        }
        return (0);
}

void    spaces_in_pipe(t_tiny *tiny, int i, char *command)
{
        char    *aux;

        if (ft_strlen(tiny->token.to_print) && tiny->tokens[i]
                && (tiny->tokens[i][0] == QUOTE || tiny->tokens[i][0] == D_QUOTE)
                && ft_strncmp(tiny->tokens[i - 1], "sed", 3))
        {
                aux = ft_strtrim(tiny->token.to_print, D_QUOTE_S);
                free_char_array2(&tiny->tokens[i + 1]);
        }
        else
                aux = ft_strtrim(tiny->tokens[i], D_QUOTE_S);
        free(tiny->tokens[i]);
        tiny->tokens[i] = aux;
        command = ft_strjoin(command, tiny->tokens[i - 1]);
        tiny->last_exit_cmd = execve(command, &tiny->tokens[i - 1], tiny->env.env);
        free(command);
}

void    execve_error(t_tiny *tiny)
{
        tiny->last_exit_cmd = 127;
        if (tiny->tokens[0][0] != '|')
                printf("minishell: %s: %s", tiny->tokens[0], ERROR_CMD);
        else if (tiny->tokens[1])
                printf("minishell: %s: %s", tiny->tokens[1], ERROR_CMD);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:38:32 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:38:33 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     tokent(char *string, char needle)
{
        int     i;

        i = 0;
        while (string[i])
        {
                if (string[i] == needle || string[i] == D_QUOTE || string[i] == QUOTE)
                        return (i);
                if (string[i] == '?')
                        return (i + 1);
                i++;
        }
        return (i);
}

int     fix(t_tiny *tiny, char c, char *aux, int nbr)
{
        if (tiny->token.quote == 0 && (c == QUOTE || c == D_QUOTE))
                tiny->token.quote = c;
        else
        {
                if (tiny->token.quote == c)
                        tiny->token.quote = 0;
                else
                {
                        aux[nbr] = c;
                        nbr++;
                }
        }
        return (nbr);
}

void    simple_quotes(t_tiny *tiny, char *in, int i, int c)
{
        char    *aux;

        tiny->token.quote = 0;
        aux = ft_strtrim(in, " ");
        tiny->has_flag = false;
        if (in[0] == '-' && in[1] == 'n')
        {
                tiny->has_flag = true;
                i += 2;
        }
        while (in[i] == ' ')
                i++;
        while (in[i])
        {
                c = fix(tiny, in[i], aux, c);
                i++;
        }
        aux[c] = '\0';
        free(tiny->token.to_print);
        tiny->token.to_print = aux;
}

void    tokenizer(t_tiny *tiny)
{
        t_token *tk;

        tk = init_tk();
        tiny->token.quote = 0;
        tk->end = ft_strdup("");
        if (tiny->line)
        {
                while ((int)ft_strlen(tiny->line) > tk->i)
                {
                        if (tiny->token.quote == 0 && (tiny->line[tk->i] == QUOTE))
                                tiny->token.quote = tiny->line[tk->i];
                        else
                        {
                                if (tiny->token.quote == tiny->line[tk->i])
                                        tiny->token.quote = 0;
                                if (tiny->line[tk->i] == '~' && tiny->token.quote == 0)
                                        get_home_sign(tiny, tk);
                                else if (tiny->line[tk->i] == '$' && tiny->token.quote == 0)
                                        get_dollar_sign(tiny, tk);
                        }
                        tk->len++;
                        tk->i++;
                }
                finish_tokenizer(tiny, tk);
        }
}
asayah@DESKTOP-AD6FET6 /m/c/U/D/D/m/m/src (master)> ls
builtins.c  ft_env.c     functions_2.c  main.c      redir_out.c     split_cmd.c
find_env.c  ft_exit.c    functions_3.c  printer.c   run_pipe.c      token.c
ft_cd.c     ft_export.c  functions_4.c  pwd.c       run_pipe_aux.c  token_utils.c
ft_echo.c   functions.c  init_path.c    redir_in.c  signal.c        unset.c
asayah@DESKTOP-AD6FET6 /m/c/U/D/D/m/m/src (master)> cat ft_cd.c ft_export.c functions_4.c pwd.c
 run_pipe_aux.c token_utils.c 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:33:41 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:33:42 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     ft_cd(t_tiny *tiny)
{
        char    *token_aux;
        bool    home;

        home = there_is_home(tiny);
        if (tiny->tokens[1])
                token_aux = ft_strdup(tiny->token.to_print);
        else
        {
                if (home == true)
                        token_aux = ft_strdup(tiny->home);
                else
                {
                        tiny->last_exit_cmd = 1;
                        printf(ERROR_HOME);
                        return (1);
                }
        }
        tiny->last_exit_cmd = chdir(token_aux);
        if (tiny->last_exit_cmd == -1)
                printf("minishell: cd: %s: %s", tiny->tokens[1], ERROR_DIR);
        free(token_aux);
        return (0);
}

bool    there_is_home(t_tiny *tiny)
{
        if (find_env(tiny, "HOME"))
                return (true);
        else
                return (false);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:35:31 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:35:35 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_export(t_tiny *tiny)
{
        int             i;
        char    **env_aux;

        i = 1;
        while (tiny->tokens[i])
        {
                env_aux = ft_split(tiny->tokens[i], '=');
                if (env_aux[1])
                        verify_if_env_exists(tiny, env_aux, i);
                else if (tiny->tokens[i][ft_strlen(tiny->tokens[1]) - 1] == '=')
                {
                        env_aux[1] = ft_strdup("");
                        verify_if_env_exists(tiny, env_aux, i);
                }
                free(env_aux[0]);
                free(env_aux[1]);
                free(env_aux);
                env_aux = NULL;
                i++;
        }
        tiny->last_exit_cmd = 0;
}

void    verify_if_env_exists(t_tiny *tiny, char **env_aux, int i)
{
        if (find_env(tiny, env_aux[0]))
        {
                free(tiny->env.content[tiny->env.index]);
                tiny->env.content[tiny->env.index] = ft_strdup(env_aux[1]);
        }
        else
                add_env(tiny, env_aux[0], env_aux[1]);
        if (!ft_strncmp(tiny->tokens[i], "PATH", 4))
        {
                if (tiny->path)
                        free_char_array(tiny->path);
                init_path(tiny);
        }
}

void    add_env(t_tiny *tiny, char *new_key, char *new_content)
{
        int     i;

        tiny->env.len++;
        alloc_env_aux(tiny);
        i = 0;
        while (i < tiny->env.len - 1)
        {
                tiny->env_aux.key[i] = ft_strdup(tiny->env.key[i]);
                tiny->env_aux.content[i] = ft_strdup(tiny->env.content[i]);
                i++;
        }
        tiny->env_aux.key[i] = ft_strdup(new_key);
        tiny->env_aux.content[i] = ft_strdup(new_content);
        i++;
        tiny->env_aux.key[i] = NULL;
        tiny->env_aux.content[i] = NULL;
        free_char_array(tiny->env.key);
        free_char_array(tiny->env.content);
        tiny->env.key = tiny->env_aux.key;
        tiny->env.content = tiny->env_aux.content;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   functions_4.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:33:46 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:33:47 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

size_t  ft_strlen(const char *str)
{
        long int        size;

        size = 0;
        while (str[size] != '\0')
        {
                size++;
        }
        return (size);
}

size_t  ft_strlcpy(char *restrict dst, const char *restrict src, size_t dstsize)
{
        size_t  i;

        i = 0;
        if (src == 0)
                return (0);
        if (dstsize > 0)
        {
                while (src[i] != '\0' && i < (dstsize - 1))
                {
                        dst[i] = src[i];
                        i++;
                }
                dst[i] = '\0';
        }
        return (ft_strlen(src));
}

char    *ft_strdup(const char *s1)
{
        char    *cpy;
        int             len;

        len = ft_strlen(s1) + 1;
        cpy = ((char *)malloc(sizeof(char) * len));
        if (!cpy)
                return (0);
        if (cpy != 0)
        {
                ft_strlcpy(cpy, s1, len);
                return (cpy);
        }
        return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwc.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:38:51 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:38:54 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_pwd(t_tiny *tiny)
{
        char    *buf;

        buf = get_cwd_buf();
        ft_putendl_fd(buf, tiny->out_fd);
        if (buf == NULL)
                tiny->last_exit_cmd = 1;
        else
                tiny->last_exit_cmd = 0;
        free(buf);
}

char    *get_cwd_buf(void)
{
        size_t  size;
        char    *buf;

        size = 2000;
        buf = NULL;
        buf = getcwd(buf, size);
        return (buf);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_pipe_aux.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:38:01 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:38:02 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    run_commands(t_tiny *tiny)
{
        int     j;
        int     fd[2];

        j = 0;
        tiny->c = 0;
        tiny->last_redir = 0;
        while (j < tiny->split.qtt_pipe)
        {
                if (pipe(fd) < 0)
                {
                        printf("Pipe error\n");
                        tiny->last_exit_cmd = 127;
                }
                tiny->out_fd = fd[1];
                run_commands_aux(tiny);
                close(tiny->out_fd);
                if (tiny->in_fd != 0)
                        close(tiny->in_fd);
                tiny->in_fd = fd[0];
                j++;
        }
        run_commands_aux(tiny);
}

void    run_commands_aux(t_tiny *tiny)
{
        action(tiny);
        if (tiny->commands[0][0] != '>')
        {
                tokenizer(tiny);
                if (tiny->tokens[0])
                        is_builtin(tiny->tokens[0], tiny);
                if (tiny->in_fd != -1)
                        exec_process(tiny, tiny->in_fd, tiny->out_fd);
                free_char_array(tiny->tokens);
                free(tiny->token.to_print);
                free(tiny->token.to_exec);
        }
        if (tiny->name_file)
                unlink(tiny->name_file);
}

void    action(t_tiny *tiny)
{
        tiny->line = ft_strdup(tiny->commands[tiny->c]);
        if (tiny->split.n_comand > 1)
                tiny->c++;
        tiny->error_name_file = NULL;
        while (tiny->commands[tiny->c] && tiny->commands[tiny->c][0] != '|')
        {
                redirect_out(tiny, tiny->c);
                redirect_in(tiny, tiny->c, NULL);
                tiny->c++;
        }
        if (tiny->error_name_file != NULL)
        {
                tiny->last_exit_cmd = 1;
                printf("minishell: %s: %s", tiny->error_name_file, ERROR_DIR);
                free(tiny->error_name_file);
        }
}

void    exec_process(t_tiny *tiny, int in, int out)
{
        pid_t   pid;

        if (tiny->is_builtin && tiny->tokens[0])
                run_builtin(tiny);
        else
        {
                pid = fork();
                run_signals(2);
                if (pid < 0)
                {
                        printf("Fork error\n");
                        tiny->last_exit_cmd = 127;
                }
                else if (pid == 0)
                {
                        file_descriptor_handler(in, out);
                        tiny->last_exit_cmd = 127;
                        ft_execve_pipe(tiny, 0, "");
                        exit(tiny->last_exit_cmd);
                }
                else
                        waitpid(pid, &tiny->last_exit_cmd, WUNTRACED);
                if (WIFEXITED(tiny->last_exit_cmd))
                        tiny->last_exit_cmd = WEXITSTATUS(tiny->last_exit_cmd);
        }
}

void    ft_execve_pipe(t_tiny *tiny, int i, char *command)
{
        if (tiny->tokens[0])
        {
                tiny->last_exit_cmd = execve(tiny->tokens[0], &tiny->tokens[0],
                                tiny->env.env);
                while (tiny->path && tiny->path[i] != NULL)
                {
                        command = ft_strdup(tiny->path[i]);
                        if (tiny->tokens[0][0] == '|' && tiny->tokens[1])
                        {
                                if (!tiny->tokens[0][1])
                                        spaces_in_pipe(tiny, 2, command);
                                else
                                {
                                        tiny->tokens[0] = &tiny->tokens[0][1];
                                        spaces_in_pipe(tiny, 1, command);
                                }
                        }
                        else
                                spaces_in_pipe(tiny, 1, command);
                        i++;
                }
                execve_error(tiny);
        }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:38:44 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:38:46 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    get_home_sign(t_tiny *tiny, t_token *tk)
{
        char    *extend;

        tk->new = substr_ft(tiny->line, tk->init, tk->len - 1);
        tk->end = ft_strjoin(tk->end, tk->new);
        free(tk->new);
        extend = tiny->home;
        tk->end = ft_strjoin(tk->end, extend);
        tk->i++;
        tk->len = 1;
        tk->init = tk->i;
}

void    get_dollar_sign(t_tiny *tiny, t_token *tk)
{
        char    *extend;
        char    *n_env;

        tk->new = substr_ft(tiny->line, tk->init, tk->len - 1);
        tk->end = ft_strjoin(tk->end, tk->new);
        free(tk->new);
        tk->posic = tokent(&tiny->line[tk->i + 1], ' ');
        n_env = substr_ft(tiny->line, tk->i + 1, tk->posic);
        if (tiny->line[tk->i + 1] != '?' && find_env(tiny, n_env))
                extend = ft_strdup(find_env(tiny, n_env));
        else if (tiny->line[tk->i + 1] == '?')
                extend = ft_itoa(tiny->last_exit_cmd);
        else
                extend = NULL;
        if (extend)
                tk->end = ft_strjoin(tk->end, extend);
        free(extend);
        tk->i += ft_strlen(n_env) + 1;
        free(n_env);
        tk->len = 1;
        tk->init = tk->i;
}

t_token *init_tk(void)
{
        t_token *tk;

        tk = (t_token *)malloc(sizeof(t_token));
        tk->end = NULL;
        tk->new = NULL;
        tk->to_exec = NULL;
        tk->to_print = NULL;
        tk->quote = '\0';
        tk->i = 0;
        tk->init = 0;
        tk->len = 1;
        tk->posic = 0;
        return (tk);
}

void    free_tk(t_token *tk)
{
        if (tk->end != NULL)
        {
                free(tk->end);
                tk->end = NULL;
        }
        if (tk->new != NULL)
        {
                free(tk->new);
                tk->new = NULL;
        }
        if (tk->to_exec != NULL)
        {
                free(tk->to_exec);
                tk->to_exec = NULL;
        }
        if (tk->to_print != NULL)
        {
                free(tk->to_print);
                tk->to_print = NULL;
        }
        free(tk);
}

void    finish_tokenizer(t_tiny *tiny, t_token *tk)
{
        tk->new = substr_ft(tiny->line, tk->init, tk->len);
        tk->end = ft_strjoin(tk->end, tk->new);
        tk->posic = tokent(tk->end, ' ');
        tiny->token.to_print = ft_strtrim(&(tk->end)[tk->posic], " ");
        tiny->token.to_exec = substr_ft(tk->end, tk->i + 1, tk->posic);
        simple_quotes(tiny, tiny->token.to_print, 0, 0);
        tiny->tokens = ft_split(tk->end, ' ');
        free_tk(tk);
        free(tiny->line);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_echo.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:34:16 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:34:18 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_echo(t_tiny *tiny)
{
        //int   j;
        //int   n;

        //n = init_echo(tiny, 0);
        //j = 0;
        if (tiny->tokens[1])
        {
                print_echo(tiny, tiny->token.to_print);
                if (!tiny->has_flag)
                        ft_putstr_fd("\n", tiny->out_fd);
        }
        else
                ft_putstr_fd("\n", tiny->out_fd);
}

int     init_echo(t_tiny *tiny, int n)
{
        if (tiny->tokens[0][0] != '|')
                n = 1;
        else
                n = 2;
        return (n);
}

void    print_echo(t_tiny *tiny, char *tiny_tokens_i)
{
        if (!ft_strncmp(tiny_tokens_i, "$?", 2))
                ft_putnbr_fd(tiny->last_exit_cmd, tiny->out_fd);
        else
        {
                ft_putstr_fd(tiny_tokens_i, tiny->out_fd);
                tiny->last_exit_cmd = 0;
        }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   functions.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:33:08 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:33:11 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_putchar_fd(char c, int fd)
{
        write(fd, &c, 1);
}

void    ft_putnbr_fd(int n, int fd)
{
        if (n == -2147483648)
                ft_putstr_fd("-2147483648", fd);
        if (n < 0 && n != -2147483648)
        {
                ft_putchar_fd('-', fd);
                n = n * -1;
        }
        if (n <= 9 && n >= 0)
                ft_putchar_fd(n + 48, fd);
        else if (n > 0)
        {
                ft_putnbr_fd(n / 10, fd);
                ft_putchar_fd(n % 10 + 48, fd);
        }
}

int     count_digits(int n)
{
        int     n_digits;

        n_digits = 0;
        if (n < 0)
                n = n * -1;
        while (n > 0)
        {
                n = n / 10;
                n_digits++;
        }
        return (n_digits);
}

int     power(int n_digits)
{
        int     p10;

        p10 = 1;
        while (n_digits > 0)
        {
                p10 = p10 * 10;
                n_digits--;
        }
        return (p10);
}

char    *ft_itoa(int n)
{
        char    *itoa;
        int             p10;
        int             i;

        itoa = (char *)malloc((count_digits(n) + 2) * sizeof(char));
        if (!itoa)
                return (NULL);
        if (n == -2147483648)
                return (substr_ft("-2147483648", 0, 11));
        i = 0;
        if (n < 0)
        {
                itoa[i++] = '-';
                n = n * (-1);
        }
        p10 = power(count_digits(n) - 1);
        while (p10 > 0)
        {
                itoa[i++] = (n / p10 % 10 + 48);
                p10 = p10 / 10;
        }
        itoa[i] = '\0';
        return (itoa);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_path.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:36:55 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:36:56 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int     init_path(t_tiny *tiny)
{
        char    *path_aux;
        int             i;

        path_aux = ft_strdup(find_env(tiny, "PATH"));
        if (!path_aux)
                return (0);
        tiny->path = ft_split(path_aux, ':');
        i = 0;
        while (tiny->path && tiny->path[i])
        {
                tiny->path[i] = ft_strjoin(tiny->path[i], "/");
                i++;
        }
        free(path_aux);
        return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_in.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:37:28 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:37:29 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    redirect_in(t_tiny *tiny, int j, char *aux)
{
        char    **file;

        if (tiny->commands[j][0] == '<')
        {
                file = NULL;
                if (tiny->commands[j][1] == '<')
                        file = double_redir(tiny, file, j);
                else
                {
                        file = ft_split(&tiny->commands[j][1], ' ');
                        tiny->in_fd = open(file[0], O_RDONLY, 0777);
                        if (tiny->in_fd == -1 && tiny->error_name_file == NULL)
                                tiny->error_name_file = ft_strdup(file[0]);
                }
                aux = ft_strtrim(tiny->line, " ");
                if (tiny->split.n_comand == 1 || (aux[0] == '|' && ft_strlen(aux) == 1))
                {
                        free(tiny->line);
                        tiny->line = new_comman(1, file);
                }
                free(aux);
                tiny->last_redir = 0;
                free_char_array(file);
        }
}

char    **double_redir(t_tiny *tiny, char **file, int j)
{
        file = ft_split(&tiny->commands[j][2], ' ');
        read_until(file[0]);
        tiny->in_fd = open(file[0], O_RDONLY | O_CREAT, 0777);
        tiny->name_file = ft_strdup(file[0]);
        tiny->is_append++;
        return (file);
}

void    read_until(char *end)
{
        char    *line;
        int             flags;
        int             fd;

        flags = O_WRONLY | O_CREAT | O_TRUNC;
        line = ft_strdup("");
        fd = open(end, flags, 0777);
        while (ft_strncmp(line, end, ft_strlen(end))
                || ft_strlen(line) != ft_strlen(end))
        {
                free(line);
                line = readline("> ");
                if (ft_strlen(line) != ft_strlen(end))
                        ft_putendl_fd(line, fd);
        }
        close(fd);
        free(line);
}

char    *new_comman(int i, char **str)
{
        char    *aux;

        aux = ft_strdup("");
        while (str[i] != NULL)
        {
                if (ft_strlen(aux) > 0)
                        aux = ft_strjoin(aux, " ");
                aux = ft_strjoin(aux, str[i]);
                i++;
        }
        return (aux);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:38:10 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/01 16:38:11 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    run_signals(int sig)
{
        if (sig == 1)
        {
                signal(SIGINT, restore_prompt);
                signal(SIGQUIT, SIG_IGN);
        }
        if (sig == 2)
        {
                signal(SIGINT, ctrl_c);
                signal(SIGQUIT, back_slash);
        }
        if (sig == 3)
        {
                printf("exit\n");
                exit(0);
        }
}

void    restore_prompt(int sig)
{
        write(1, "\n", 1);
        rl_replace_line("", 0);
        rl_on_new_line();
        rl_redisplay();
        (void)sig;
}

void    ctrl_c(int sig)
{
        write(1, "\n", 1);
        (void)sig;
}

void    back_slash(int sig)
{
        printf("Quit (core dumped)\n");
        (void)sig;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ancardos <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 11:39:12 by ancardos          #+#    #+#             */
/*   Updated: 2024/11/04 11:39:15 by ancardos         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void    ft_unset(t_tiny *tiny)
{
        int     i;

        i = 1;
        while (tiny->tokens[i])
        {
                if (find_env(tiny, tiny->tokens[i]))
                {
                        rm_env(tiny);
                        if (!ft_strncmp(tiny->tokens[i], "PATH", 4))
                        {
                                free_char_array(tiny->path);
                                tiny->path = NULL;
                        }
                }
                i++;
        }
        tiny->last_exit_cmd = 0;
}

void    rm_env(t_tiny *tiny)
{
        int     i;
        int     j;

        tiny->env.len--;
        alloc_env_aux(tiny);
        i = 0;
        j = 0;
        while (i < tiny->env.len + 1)
        {
                if (i != tiny->env.index)
                {
                        tiny->env_aux.key[j] = ft_strdup(tiny->env.key[i]);
                        tiny->env_aux.content[j] = ft_strdup(tiny->env.content[i]);
                        j++;
                }
                i++;
        }
        tiny->env_aux.key[j] = NULL;
        tiny->env_aux.content[j] = NULL;
        free_char_array(tiny->env.key);
        free_char_array(tiny->env.content);
        tiny->env.key = tiny->env_aux.key;
        tiny->env.content = tiny->env_aux.content;
}

void    alloc_env_aux(t_tiny *tiny)
{
        tiny->env_aux.key = malloc(sizeof(char *) * (tiny->env.len + 1));
        if (!tiny->env_aux.key)
                exit(EXIT_FAILURE);
        tiny->env_aux.content = malloc(sizeof(char *) * (tiny->env.len + 1));
        if (!tiny->env_aux.content)
                exit(EXIT_FAILURE);
}